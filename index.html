<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLIZA's Tactical Bag Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-left, .header-right {
            display: flex;
            gap: 15px;
        }

        .stat-chip {
            background: #333;
            padding: 10px 20px;
            border: 1px solid #fff;
            border-radius: 5px;
            font-weight: bold;
        }

        .main-content {
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex: 1;
            height: calc(100vh - 120px);
        }

        /* Character Panel - Left */
        .character-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
        }

        .character-video {
            width: 90%;
            height: 80%;
            object-fit: cover;
            border-radius: 8px;
            background: #222;
        }

        /* Inventory Panel - Middle */
        .inventory-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
        }

        .inventory-grid {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 360px;
            background: url('static/enven.png') no-repeat center center;
            background-size: cover;
            border: 2px solid #666;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .inventory-grid::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            z-index: 0;
        }

        .grid-cell {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 1px solid rgba(68, 68, 68, 0.6);
            transition: background-color 0.2s;
            z-index: 1;
        }

        .grid-cell:hover {
            background: #333;
        }

        .grid-cell.preview-valid {
            background: rgba(0, 255, 255, 0.3);
        }

        .grid-cell.preview-invalid {
            background: rgba(255, 0, 0, 0.3);
        }

        .inventory-item {
            position: absolute;
            background: rgba(85, 85, 85, 0.9);
            border: 2px solid #777;
            border-radius: 6px;
            cursor: grab;
            padding: 4px;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .inventory-item:hover {
            border-color: #4af;
        }

        .inventory-item.on-cooldown {
            opacity: 0.5;
            position: relative;
        }

        .inventory-item.on-cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 6px;
            z-index: 3;
        }

        .cooldown-timer {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 10px;
            font-weight: bold;
            padding: 1px 3px;
            border-radius: 3px;
            z-index: 4;
            min-width: 20px;
            text-align: center;
        }

        .inventory-item:active {
            cursor: grabbing;
        }

        .item-image {
            max-width: 90%;
            max-height: 60%;
            object-fit: contain;
            filter: drop-shadow(0 0 2px #fff);
        }

        .item-level {
            color: #ffa500;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            margin-top: 2px;
        }

        .item-dps {
            color: #4af;
            font-size: 8px;
            text-shadow: 0 0 2px #000;
        }

        .stats-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            padding: 10px 15px;
            border-radius: 5px;
        }

        .stat-value {
            font-weight: bold;
        }

        .upgrade-btn {
            background: #666;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .upgrade-btn:hover {
            background: #777;
        }

        .upgrade-btn:disabled {
            background: #444;
            cursor: not-allowed;
        }

        /* Game Panel - Right */
        .game-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
        }

        .shop-container {
            width: 100%;
            padding: 20px;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .shop-items {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            max-height: 600px;
            overflow-y: auto;
        }

        .shop-item {
            background: #333;
            border: 1px solid #666;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            position: relative;
            cursor: grab;
            transition: all 0.2s ease;
            width: 180px;
            min-height: 100px;
        }

        .shop-item:hover {
            border-color: #888;
        }

        .shop-item-grid {
            display: inline-block;
            position: relative;
            background: rgba(34, 34, 34, 0.8);
            border: 1px solid #555;
            border-radius: 4px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .shop-item-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            filter: drop-shadow(0 0 2px #fff);
        }

        .shop-item-name {
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: capitalize;
        }

        .shop-item-info {
            font-size: 12px;
            color: #fff;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .shop-item-dps {
            font-size: 12px;
            color: #fff;
            margin-bottom: 10px;
        }

        .reroll-btn {
            background: #555;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }

        .reroll-btn:hover {
            background: #666;
        }

        .reroll-btn:disabled {
            background: #333;
            cursor: not-allowed;
        }

        .action-btn {
            background: #555;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }

        .action-btn.blue {
            background: #666;
        }

        .action-btn:hover {
            opacity: 0.8;
        }

        .combat-screen {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            height: 100%;
            position: relative;
            background: url('static/battle.png') no-repeat center center;
            background-size: cover;
            border-radius: 8px;
            overflow: hidden;
        }

        .combat-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        .combat-character {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 80 !important;
        }

        .combat-character img {
            width: 240px;
            height: 300px;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }

        .combat-enemy {
            position: absolute;
            top: 60%;
            left: 60%;
            transform: translate(-50%, -50%);
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .combat-enemy img {
            width: 370px;
            height: 370px;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }
        .enemy-health-container {
            display: none;
        }

        .enemy-name {
            color: #fff;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: #444;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #aa2222);
            transition: width 0.3s;
            border-radius: 8px;
        }

        .shield-bar {
            width: 200px;
            height: 15px;
            background: #444;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 5px;
            border: 2px solid #666;
        }

        .shield-fill {
            height: 100%;
            background: linear-gradient(to right, #aa44ff, #6622aa);
            transition: width 0.3s;
            border-radius: 6px;
        }

        .combat-stats {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #666;
            z-index: 3;
        }

        .combat-stats div {
            font-size: 16px;
            margin: 5px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .enemy-sprite {
            font-size: 80px;
            margin-bottom: 10px;
            display: none;
        }

        .hidden {
            display: none;
        }

        .dragging {
            opacity: 0.5;
            z-index: 1000;
        }

        .merge-animation {
            animation: mergeGlow 0.5s ease-in-out;
        }

        .screen-shake {
            animation: shake 0.3s ease-in-out;
        }
        

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }

        .damage-flash {
            animation: damageFlash 0.2s ease-in-out;
        }

        @keyframes damageFlash {
            0% { background: rgba(255, 0, 0, 0); }
            50% { background: rgba(255, 0, 0, 0.3); }
            100% { background: rgba(255, 0, 0, 0); }
        }

        .hit-flash {
            animation: hitFlash 0.15s ease-in-out;
        }

        @keyframes hitFlash {
            0% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.5) saturate(1.8) hue-rotate(-10deg); }
            100% { filter: brightness(1) saturate(1); }
        }

        .attack-flash {
            animation: attackFlash 0.1s ease-in-out;
        }

        @keyframes attackFlash {
            0% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.3) saturate(1.5) hue-rotate(20deg); }
            100% { filter: brightness(1) saturate(1); }
        }

        .damage-number {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 100;
            animation: damageNumberFloat 1s ease-out forwards;
        }

        .damage-number.player-damage {
            color: #ff4444;
        }

        .damage-number.enemy-damage {
            color: #ffaa44;
        }

        .damage-number.shield-damage {
            color: #aa44ff;
        }

        #hp-display {
            display: none;
        }

        @keyframes damageNumberFloat {
            0% {
                transform: translateY(0) scale(1.2);
                opacity: 1;
            }
            50% {
                transform: translateY(-30px) scale(1);
                opacity: 0.8;
            }
            100% {
                transform: translateY(-60px) scale(0.8);
                opacity: 0;
            }
        }

        .muzzle-flash {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #ffff88 0%, #ffaa44 50%, transparent 70%);
            border-radius: 50%;
            z-index: 50;
            opacity: 0;
            animation: muzzleFlash 0.1s ease-out;
        }

        @keyframes muzzleFlash {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2);
            }
            100% {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        .impact-effect {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff6644 0%, #ffaa44 30%, transparent 70%);
            border-radius: 50%;
            z-index: 50;
            opacity: 0;
            animation: impactEffect 0.2s ease-out;
        }

        @keyframes impactEffect {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                opacity: 0.9;
                transform: scale(1.5);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        @keyframes mergeGlow {
            0% { box-shadow: 0 0 0 rgba(74, 255, 74, 0.8); }
            50% { box-shadow: 0 0 20px rgba(74, 255, 74, 0.8); }
            100% { box-shadow: 0 0 0 rgba(74, 255, 74, 0.8); }
        }

        .image-error {
            background: #555;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        #mobile-block {
            display: none;
            position: fixed;
            inset: 0;
            background: #fff;
            z-index: 99999;
            align-items: center;
            justify-content: center;
        }
            #mobile-block img {
            max-width: 80vw;
            height: auto;
        }

        @media (max-width: 900px), (hover: none) and (pointer: coarse) {
            body { background: #fff !important; }
            .game-container { display: none !important; }
            #mobile-block { display: flex !important; }
        }

    </style>
</head>
<body>
    <div id="mobile-block">
        <img src="static/no.png" alt="Mobile not supported">
    </div>
    <div class="game-container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="stat-chip">DEMO: CLIZA</div>
                <div class="stat-chip" id="resource-display">Gold: 200</div>
            </div>
            <div class="header-right">
                <div class="stat-chip hidden" id="hp-display">HP: 100</div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Character Panel - Left -->
            <div class="character-panel">
                <video class="character-video" autoplay loop muted>
                    <source src="static/cliza-ready.mp4" type="video/mp4">
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                        Video not supported
                    </div>
                </video>
            </div>

            <!-- Inventory Panel - Middle -->
            <div class="inventory-panel">
                <div class="inventory-grid" id="inventory-grid">
                    <!-- Grid cells will be generated by JS -->
                </div>

                <div class="stats-panel">
                    <div class="stat-row">
                        <div>
                            <span style="color: #fff;">ATK:</span>
                            <span class="stat-value" id="attack-value">0</span>
                        </div>
                    </div>
                    <div class="stat-row">
                        <div>
                            <span style="color: #fff;">HEAL:</span>
                            <span class="stat-value" id="heal-value">0.0/s</span>
                        </div>
                    </div>
                    <div class="stat-row">
                        <div>
                            <span style="color: #fff;">SHIELD:</span>
                            <span class="stat-value" id="shield-value">0</span>
                        </div>
                    </div>
                    <div class="stat-row">
                        <div>
                            <span style="color: #fff;">HP:</span>
                            <span class="stat-value" id="hp-value">100/100</span>
                        </div>
                        <button class="upgrade-btn hidden" id="hp-upgrade" onclick="upgradeMetaStat('hp')">
                        +10 (10D)
                        </button>
                    </div>
                </div>
            </div>

            <!-- Game Panel - Right (Shop/Combat/Lobby) -->
            <div class="game-panel">
                <!-- Lobby Screen -->
                <div id="lobby-screen">
                    <button class="action-btn blue" onclick="startShop()">
                        Start Day <span id="day-number">1</span>
                    </button>
                </div>

                <!-- Shop Screen -->
                <div id="shop-screen" class="shop-container hidden">
                    <div class="shop-header">
                        <h2>Shop</h2>
                        <button class="reroll-btn" id="reroll-btn" onclick="rerollShop()">
                            Reroll (5G)
                        </button>
                    </div>

                    <div class="shop-items" id="shop-items">
                        <!-- Shop items will be generated by JS -->
                    </div>

                    <button class="action-btn" onclick="startCombat()">
                        Start Combat
                    </button>
                </div>

                <!-- Combat Screen -->
                <div id="combat-screen" class="combat-screen hidden">
                    <div id="cutscene-overlay" class="hidden"
                        style="position:absolute; top:0; left:0; width:100%; height:100%; 
                                display:flex; align-items:center; justify-content:center; z-index:100;">
                        <img id="cutscene-image" src="" alt="Cutscene"
                            class="hidden"
                            style="max-width:90%; max-height:90%; border:3px solid #fff; border-radius:8px;">
                    </div>
                    <!-- Character positioned at bottom-left -->
                    <div class="combat-character">
                        <img src="static/cliza_back.png" alt="Character" onerror="this.style.display='none';">
                    </div>

                    <!-- Enemy positioned at top-right -->
                    <div class="combat-enemy">
                        <img id="monster" alt="Monster" style="display:none;" onerror="this.style.display='none'">
                        
                        <!-- Enemy health bar -->
                        <div class="enemy-health-container">
                            <div class="enemy-name">Enemy</div>
                            <div class="health-bar">
                                <div class="health-fill" id="enemy-health-fill"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Player shield bar (when active) -->
                    <div class="shield-bar hidden" id="player-shield-bar" style="position: absolute; bottom: 450px; left: 40px; z-index: 3; width: 250px;">
                        <div class="shield-fill" id="player-shield-fill"></div>
                    </div>

                    <!-- Combat stats in center -->
                    <div class="combat-stats">
                        <div>Grok HP: <span id="enemy-hp-text">100</span> / <span id="enemy-max-hp-text">100</span></div>
                        <div id="player-shield-text" class="hidden" style="color: #a4f;">Player Shield: 0</div>
                    </div>

                    <!-- Hidden elements for compatibility -->
                    <div class="enemy-sprite">ðŸ¤–</div>
                    <h2 style="display: none;">Enemy</h2>
                </div>
            </div>
        </div>
    </div>

    <script>
        let gameState = {
            playerHp: 100,
            playerMaxHp: 100,
            shieldHp: 0,
            maxShield: 0,
            gold: 200,
            gems: 20,
            day: 1,
            gamePhase: 'LOBBY',
            inventory: Array(8).fill(null).map(() => Array(6).fill(null)),
            enemyHp: 100,
            enemyMaxHp: 100,
            metaUpgrades: { attack: 0, defense: 0, hp: 0 },
            weaponCooldowns: {},
            combatInterval: null,
            weaponIntervals: {},
            cutsceneShown: { "90": false, "70": false, "50": false, "30": false, "10": false }
        };
        const GOLD_TO_GEM_RATE = 1; 

        const MONSTER_IMAGES = ["static/mon_01.png", "static/mon_02.png", "static/mon_03.png"];

        function setRandomMonster() {
            const el = document.getElementById("monster");
            if (!el) return;

            const randomImg = MONSTER_IMAGES[Math.floor(Math.random() * MONSTER_IMAGES.length)];
            el.style.display = "block";
            el.src = `${randomImg}?r=${Math.random().toString(36).slice(2)}`;
        }

        const WEAPON_STATS = {
            pistol: { dps: 8, interval: 0.8, upgrade: 2, size: [2, 2] },
            rifle: { dps: 15, interval: 1.2, upgrade: 3, size: [2, 3] },
            shotgun: { dps: 20, interval: 2.0, upgrade: 5, size: [2, 3] },
            sniper: { dps: 40, interval: 3.0, upgrade: 8, size: [3, 4] }
        };

        const ITEM_SIZES = {
            pistol:  [2, 2],
            rifle:   [3, 2],
            shotgun: [3, 2],
            sniper:  [5, 3],
            helmet: [2, 2], vest: [2, 3],
            heal: [2, 2]
        };

        let draggedItem = null;
        let previewCells = [];

        function startShop() {
            gameState.gamePhase = 'SHOP';
            showScreen('shop-screen');
            updateUI();
        }

        function startCombat() {
            gameState.gamePhase = 'COMBAT';
            gameState.enemyHp = 100 + (gameState.day - 1) * 20;
            gameState.enemyMaxHp = gameState.enemyHp;
            gameState.shieldHp = 0;
            
            gameState.maxShield = calculateMaxShield();
            
            renderInventory();

            setRandomMonster();     
            showScreen('combat-screen');
            updateUI();
            updateCombatUI();
            
            startCombatLoop();
        }

        function rerollShop() {
            if (gameState.gold >= 5) {
                gameState.gold -= 5;
                generateShopItems();
                updateUI();
            }
        }

        function upgradeMetaStat(stat = 'hp') {
            if (stat !== 'hp') return;

            const cost = 10;
            const maxLevel = 10;

            if (gameState.gems >= cost && gameState.metaUpgrades.hp < maxLevel) {
                gameState.gems -= cost;
                gameState.metaUpgrades.hp++;

                gameState.playerMaxHp += 10;
                gameState.playerHp = gameState.playerMaxHp; 

                updateUI();
            }
        }

        function createItemImage(itemType, fallbackText = '?') {
            const img = document.createElement('img');
            img.className = 'item-image';
            img.src = `static/${itemType}.png`;
            
            img.onerror = function() {
                const fallback = document.createElement('div');
                fallback.className = 'image-error';
                fallback.textContent = fallbackText;
                fallback.style.width = img.style.width || '100%';
                fallback.style.height = img.style.height || '100%';
                img.parentNode.replaceChild(fallback, img);
            };
            
            return img;
        }

        function initGame() {
            createInventoryGrid();
            updateUI();
            generateShopItems();
            
            const testItem1 = createItem('weapon', 'pistol', 0);
            const testItem2 = createItem('armor', 'vest', 0);
            placeItem(testItem1, 0, 0);
            placeItem(testItem2, 0, 2);
        }

        function createInventoryGrid() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';
            
            for (let x = 0; x < 8; x++) {
                for (let y = 0; y < 6; y++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.style.left = `${x * 60}px`;
                    cell.style.top = `${y * 60}px`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    cell.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        handleDragOver(e);
                    });
                    
                    cell.addEventListener('drop', function(e) {
                        e.preventDefault();
                        handleDrop(e);
                    });
                    
                    grid.appendChild(cell);
                }
            }
        }

        function createItem(type, subType, level = 0) {
            return {
                id: Math.random().toString(36).substr(2, 9),
                type: type,
                subType: subType,
                level: level,
                size: ITEM_SIZES[subType] || [1, 1]
            };
        }

        function generateShopItems() {
            const weapons = ['pistol', 'rifle', 'shotgun', 'sniper'];
            const armors = ['helmet', 'vest'];
            const items = [];
            
            const minLevel = Math.max(0, Math.floor((gameState.day - 1) / 2));
            const maxLevel = Math.min(5, gameState.day - 1 + Math.floor(gameState.day / 3));
            
            for (let i = 0; i < 3; i++) {
                const rand = Math.random();
                const itemLevel = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));
                
                if (rand < 0.4) {
                    items.push(createItem('weapon', weapons[Math.floor(Math.random() * weapons.length)], itemLevel));
                } else if (rand < 0.6) {
                    items.push(createItem('armor', armors[Math.floor(Math.random() * armors.length)], itemLevel));
                } else {
                    items.push(createItem('heal', 'heal', itemLevel));
                }
            }
            
            displayShopItems(items);
            gameState.shopItems = items;
        }


        function displayShopItems(items) {
            const container = document.getElementById('shop-items');
            container.innerHTML = '';
            
            items.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item';
                itemDiv.draggable = true;
                itemDiv.dataset.itemId = item.id;
                itemDiv.dataset.itemIndex = index;
                
                const gridContainer = document.createElement('div');
                gridContainer.className = 'shop-item-grid';
                const [width, height] = item.size;
                gridContainer.style.width = `${Math.max(60, width * 20)}px`;
                gridContainer.style.height = `${Math.max(40, height * 15)}px`;
                
                const itemImage = createItemImage(item.subType, item.subType.charAt(0).toUpperCase());
                itemImage.className = 'shop-item-image';
                gridContainer.appendChild(itemImage);
                
                let dpsText = '';
                if (item.type === 'weapon') {
                    const stats = WEAPON_STATS[item.subType];
                    const dps = stats.dps + (item.level * stats.upgrade);
                    dpsText = `<div class="shop-item-dps">${dps} DPS</div>`;
                }
                
                itemDiv.innerHTML = `
                    <div class="shop-item-name">${item.subType}</div>
                    <div class="shop-item-info">+${item.level}</div>
                    ${dpsText}
                `;
                
                itemDiv.insertBefore(gridContainer, itemDiv.firstChild.nextSibling.nextSibling);
                
        
                itemDiv.addEventListener('dragstart', (e) => {
                    draggedItem = { ...item, source: 'shop', shopIndex: index };
                    itemDiv.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', item.id);
                });
                
         
                itemDiv.addEventListener('dragend', (e) => {
                    itemDiv.classList.remove('dragging');
                    itemDiv.style.border = '1px solid #666';
                    itemDiv.style.backgroundColor = '#333';
                });
                
       
                itemDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (draggedItem && draggedItem.source === 'shop' && 
                        draggedItem.id !== item.id &&
                        canMergeItems(item, draggedItem)) {
                        
                        itemDiv.style.border = '3px solid #4a4';
                        itemDiv.style.backgroundColor = 'rgba(74, 255, 74, 0.3)';
                        e.dataTransfer.dropEffect = 'copy';
                    }
                    else if (draggedItem && draggedItem.source === 'inventory' &&
                             canMergeItems(item, draggedItem)) {
                        
                        itemDiv.style.border = '3px solid #44a';
                        itemDiv.style.backgroundColor = 'rgba(68, 170, 255, 0.3)';
                        e.dataTransfer.dropEffect = 'move';
                    } 
                    else {
                        itemDiv.style.border = '1px solid #666';
                        itemDiv.style.backgroundColor = '#333';
                        e.dataTransfer.dropEffect = 'none';
                    }
                });
                
                itemDiv.addEventListener('dragleave', (e) => {
                    e.stopPropagation();
                    itemDiv.style.border = '1px solid #666';
                    itemDiv.style.backgroundColor = '#333';
                });
        
                itemDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
           
                    if (draggedItem && draggedItem.source === 'shop' && 
                        draggedItem.id !== item.id &&
                        canMergeItems(item, draggedItem)) {
                        
                        item.level++;
                        
                        const draggedIndex = gameState.shopItems.findIndex(shopItem => shopItem.id === draggedItem.id);
                        if (draggedIndex !== -1) {
                            gameState.shopItems.splice(draggedIndex, 1);
                        }
                        
                        displayShopItems(gameState.shopItems);
                        draggedItem = null;
                        return;
                    }
                    
               
                    if (draggedItem && draggedItem.source === 'inventory') {
                        if (canMergeItems(item, draggedItem)) {
                            item.level++;
                            draggedItem = null;
                            displayShopItems(gameState.shopItems);
                            renderInventory();
                            updateStats();
                            return;
                        }
                    }
                    
                    itemDiv.style.border = '1px solid #666';
                    itemDiv.style.backgroundColor = '#333';
                });
                
                container.appendChild(itemDiv);
            });
            
            setupShopContainer();
        }

   
        function setupShopContainer() {
            const shopContainer = document.getElementById('shop-items');
            const shopScreen = document.getElementById('shop-screen');
            
            [shopContainer, shopScreen].forEach(element => {
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (draggedItem && draggedItem.source === 'inventory') {
                        e.dataTransfer.dropEffect = 'move';
                        if (element === shopContainer) {
                            shopContainer.style.backgroundColor = 'rgba(68, 170, 255, 0.1)';
                            shopContainer.style.border = '2px dashed #44a';
                        }
                    } else {
                        e.dataTransfer.dropEffect = 'none';
                    }
                });
                
                element.addEventListener('dragleave', (e) => {
                    if (element === shopContainer) {
                        shopContainer.style.backgroundColor = '';
                        shopContainer.style.border = '';
                    }
                });
                
                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (draggedItem && draggedItem.source === 'inventory' && 
                        !e.target.classList.contains('shop-item') &&
                        !e.target.closest('.shop-item')) {
                        
                        const newShopItem = { 
                            ...draggedItem,
                            id: Math.random().toString(36).substr(2, 9)
                        };
                        gameState.shopItems.push(newShopItem);
                        
                        draggedItem = null;
                        displayShopItems(gameState.shopItems);
                        renderInventory();
                        updateStats();
                        
                        if (element === shopContainer) {
                            shopContainer.style.backgroundColor = '';
                            shopContainer.style.border = '';
                        }
                        return;
                    }
                    
                    if (element === shopContainer) {
                        shopContainer.style.backgroundColor = '';
                        shopContainer.style.border = '';
                    }
                });
            });
        }


        function handleDragOver(e) {
            e.preventDefault();
            if (!draggedItem) return;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);
            
            clearPreview();
            
            if (draggedItem.source === 'shop') {
                const overlappingItem = findOverlappingItem(draggedItem, x, y);
                if (overlappingItem && canMergeItems(overlappingItem, draggedItem)) {
                    showMergePreview(overlappingItem);
                    return;
                }
                
                const canPlace = canPlaceItem(draggedItem, x, y);
                showPreview(x, y, draggedItem.size, canPlace);
            }
            
            if (draggedItem.source === 'inventory') {
                const overlappingItem = findOverlappingItem(draggedItem, x, y);
                if (overlappingItem && canMergeItems(overlappingItem, draggedItem)) {
                    showMergePreview(overlappingItem);
                    return;
                }
                
                const canPlace = canPlaceItem(draggedItem, x, y);
                showPreview(x, y, draggedItem.size, canPlace);
            }
        }

  
        function findOverlappingItem(dragItem, dropX, dropY) {
            const [dragWidth, dragHeight] = dragItem.size;
            
            for (let checkX = 0; checkX < 8; checkX++) {
                for (let checkY = 0; checkY < 6; checkY++) {
                    const item = gameState.inventory[checkX][checkY];
                    if (item && typeof item === 'object') {
                        let itemStartX = checkX;
                        let itemStartY = checkY;
                        
                        for (let x = 0; x < 8; x++) {
                            for (let y = 0; y < 6; y++) {
                                if (gameState.inventory[x][y] === item) {
                                    itemStartX = x;
                                    itemStartY = y;
                                    break;
                                }
                            }
                        }
                        
                        const [itemWidth, itemHeight] = item.size;
                        
                        const dragLeft = dropX;
                        const dragRight = dropX + dragWidth;
                        const dragTop = dropY;
                        const dragBottom = dropY + dragHeight;
                        
                        const itemLeft = itemStartX;
                        const itemRight = itemStartX + itemWidth;
                        const itemTop = itemStartY;
                        const itemBottom = itemStartY + itemHeight;
                        
                        const hasOverlap = !(dragLeft >= itemRight || dragRight <= itemLeft || 
                                           dragTop >= itemBottom || dragBottom <= itemTop);
                        
                        if (hasOverlap) {
                            return item;
                        }
                    }
                }
            }
            
            return null;
        }


        function canMergeItems(item1, item2) {
            return item1.type === item2.type && 
                   item1.subType === item2.subType && 
                   item1.level === item2.level;
        }


        function showMergePreview(targetItem) {
            for (let x = 0; x < 8; x++) {
                for (let y = 0; y < 6; y++) {
                    if (gameState.inventory[x][y] === targetItem) {
                        const [width, height] = targetItem.size;
                        for (let dx = 0; dx < width; dx++) {
                            for (let dy = 0; dy < height; dy++) {
                                const cell = document.querySelector(`[data-x="${x + dx}"][data-y="${y + dy}"]`);
                                if (cell) {
                                    cell.classList.add('preview-valid');
                                    cell.style.background = 'rgba(74, 255, 74, 0.5)';
                                    previewCells.push(cell);
                                }
                            }
                        }
                        return;
                    }
                }
            }
        }


        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedItem) return;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);
            
    
            if (draggedItem.source === 'shop') {
                const overlappingItem = findOverlappingItem(draggedItem, x, y);
                if (overlappingItem && canMergeItems(overlappingItem, draggedItem)) {
                    overlappingItem.level++;
                    removeShopItem(draggedItem.id);
                    clearPreview();
                    draggedItem = null;
                    renderInventory();
                    updateStats();
                    return;
                }
                
                if (canPlaceItem(draggedItem, x, y)) {
                    placeItem(draggedItem, x, y);
                    removeShopItem(draggedItem.id);
                    clearPreview();
                    draggedItem = null;
                    return;
                }
            }
            
  
            if (draggedItem.source === 'inventory') {
                const overlappingItem = findOverlappingItem(draggedItem, x, y);
                if (overlappingItem && canMergeItems(overlappingItem, draggedItem)) {
                    overlappingItem.level++;
                    clearPreview();
                    draggedItem = null;
                    renderInventory();
                    updateStats();
                    
               
                    setTimeout(() => {
                        const itemElements = document.querySelectorAll('.inventory-item');
                        itemElements.forEach(element => {
                            if (element.dataset && element.dataset.itemId === overlappingItem.id) {
                                element.classList.add('merge-animation');
                                setTimeout(() => {
                                    element.classList.remove('merge-animation');
                                }, 500);
                            }
                        });
                    }, 100);
                    return;
                }
                
                if (canPlaceItem(draggedItem, x, y)) {
                    placeItem(draggedItem, x, y);
                    clearPreview();
                    draggedItem = null;
                    return;
                }
            }
            
            clearPreview();
        }


        function canPlaceItem(item, startX, startY) {
            const [width, height] = item.size;
            
            if (startX + width > 8 || startY + height > 6) return false;
            
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height; y++) {
                    if (gameState.inventory[x][y] !== null) return false;
                }
            }
            return true;
        }


        function placeItem(item, startX, startY) {
            const [width, height] = item.size;
            
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height; y++) {
                    gameState.inventory[x][y] = (x === startX && y === startY) ? item : 'occupied';
                }
            }
            
            renderInventory();
            updateStats();
        }


        function showPreview(x, y, size, isValid) {
            const [width, height] = size;
            
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < height; dy++) {
                    const cell = document.querySelector(`[data-x="${x + dx}"][data-y="${y + dy}"]`);
                    if (cell) {
                        cell.classList.add(isValid ? 'preview-valid' : 'preview-invalid');
                        previewCells.push(cell);
                    }
                }
            }
        }

    
        function clearPreview() {
            previewCells.forEach(cell => {
                cell.classList.remove('preview-valid', 'preview-invalid');
                cell.style.background = '';
            });
            previewCells = [];
        }


        function removeShopItem(itemId) {
            gameState.shopItems = gameState.shopItems.filter(i => i.id !== itemId);
            displayShopItems(gameState.shopItems);
        }

  
        function renderInventory() {
            const grid = document.getElementById('inventory-grid');
            
            const existingItems = grid.querySelectorAll('.inventory-item');
            existingItems.forEach(item => item.remove());
            
            for (let x = 0; x < 8; x++) {
                for (let y = 0; y < 6; y++) {
                    const item = gameState.inventory[x][y];
                    if (item && typeof item === 'object') {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        itemDiv.dataset.itemId = item.id;
                        itemDiv.dataset.x = x;
                        itemDiv.dataset.y = y;
                        
                        const itemWidth = Math.min(item.size[0] * 60 - 4, (8 - x) * 60 - 4);
                        const itemHeight = Math.min(item.size[1] * 60 - 4, (6 - y) * 60 - 4);
                        
                        itemDiv.style.left = `${x * 60 + 2}px`;
                        itemDiv.style.top = `${y * 60 + 2}px`;
                        itemDiv.style.width = `${itemWidth}px`;
                        itemDiv.style.height = `${itemHeight}px`;
                        
                        const itemImage = createItemImage(item.subType, item.subType.charAt(0).toUpperCase());
                        itemImage.style.maxWidth = `${Math.min(80, itemWidth - 8)}%`;
                        itemImage.style.maxHeight = `${Math.min(50, itemHeight - 20)}%`;
                        itemImage.style.position = 'relative';
                        itemImage.style.zIndex = '1';
                        itemDiv.appendChild(itemImage);
                        
                        if (item.level > 0 && itemHeight >= 30) {
                            const levelDiv = document.createElement('div');
                            levelDiv.className = 'item-level';
                            levelDiv.textContent = `+${item.level}`;
                            levelDiv.style.position = 'relative';
                            levelDiv.style.zIndex = '1';
                            itemDiv.appendChild(levelDiv);
                        }
                        
                        if (item.type === 'weapon' && itemHeight >= 50) {
                            const stats = WEAPON_STATS[item.subType];
                            const dps = stats.dps + (item.level * stats.upgrade);
                            const dpsDiv = document.createElement('div');
                            dpsDiv.className = 'item-dps';
                            dpsDiv.textContent = `${dps} DPS`;
                            dpsDiv.style.position = 'relative';
                            dpsDiv.style.zIndex = '1';
                            itemDiv.appendChild(dpsDiv);
                        }
                        
                   
                        if (gameState.gamePhase !== 'COMBAT') {
                            itemDiv.draggable = true;
                            itemDiv.style.pointerEvents = 'auto';
                            itemDiv.style.zIndex = '10';
                            
                            itemDiv.addEventListener('dragstart', (e) => {
                                removeItemFromInventory(item, x, y);
                                draggedItem = { ...item, source: 'inventory', originalX: x, originalY: y };
                                itemDiv.style.opacity = '0.5';
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('text/plain', item.id);
                            });
                            
                            itemDiv.addEventListener('dragend', (e) => {
                                if (draggedItem && draggedItem.source === 'inventory' && draggedItem.id === item.id) {
                                    placeItem(draggedItem, draggedItem.originalX, draggedItem.originalY);
                                    draggedItem = null;
                                }
                                itemDiv.style.opacity = '1';
                            });

                       
                            itemDiv.addEventListener('dragover', (e) => {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                
                                if (draggedItem && draggedItem.source === 'inventory' && 
                                    draggedItem.id !== item.id &&
                                    canMergeItems(item, draggedItem)) {
                                    
                                    itemDiv.style.border = '3px solid #4a4';
                                    itemDiv.style.backgroundColor = 'rgba(74, 255, 74, 0.3)';
                                    e.dataTransfer.dropEffect = 'move';
                                } else if (draggedItem && draggedItem.source === 'shop' &&
                                          canMergeItems(item, draggedItem)) {
                                    
                                    itemDiv.style.border = '3px solid #44a';
                                    itemDiv.style.backgroundColor = 'rgba(68, 170, 255, 0.3)';
                                    e.dataTransfer.dropEffect = 'copy';
                                } else {
                                    itemDiv.style.border = '2px solid #777';
                                    itemDiv.style.backgroundColor = 'rgba(85, 85, 85, 0.9)';
                                    e.dataTransfer.dropEffect = 'none';
                                }
                            });

                      
                            itemDiv.addEventListener('dragleave', (e) => {
                                itemDiv.style.border = '2px solid #777';
                                itemDiv.style.backgroundColor = 'rgba(85, 85, 85, 0.9)';
                            });

                   
                            itemDiv.addEventListener('drop', (e) => {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                
                      
                                if (draggedItem && draggedItem.source === 'inventory' && 
                                    draggedItem.id !== item.id &&
                                    canMergeItems(item, draggedItem)) {
                                    
                                    item.level++;
                                    draggedItem = null;
                                    renderInventory();
                                    updateStats();
                                    return true;
                                }
                                
                         
                                if (draggedItem && draggedItem.source === 'shop' &&
                                    canMergeItems(item, draggedItem)) {
                                    
                                    item.level++;
                                    removeShopItem(draggedItem.id);
                                    draggedItem = null;
                                    renderInventory();
                                    updateStats();
                                    return true;
                                }
                                
                                itemDiv.style.border = '2px solid #777';
                                itemDiv.style.backgroundColor = 'rgba(85, 85, 85, 0.9)';
                                return false;
                            });
                        } else {
                            itemDiv.draggable = false;
                            itemDiv.style.cursor = 'default';
                            itemDiv.style.pointerEvents = 'none';
                        }
                        
                        grid.appendChild(itemDiv);
                    }
                }
            }
        }

    
        function removeItemFromInventory(item, startX, startY) {
            const [width, height] = item.size;
            
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height; y++) {
                    gameState.inventory[x][y] = null;
                }
            }
        }

 
        function findItemsInInventory(type, subType = null) {
            const items = [];
            for (let x = 0; x < 8; x++) {
                for (let y = 0; y < 6; y++) {
                    const item = gameState.inventory[x][y];
                    if (item && typeof item === 'object' && item.type === type && (!subType || item.subType === subType)) {
                        items.push(item);
                    }
                }
            }
            return items;
        }


        function calculateTotalDPS() {
            const weapons = findItemsInInventory('weapon');
            let totalDPS = 0;
            weapons.forEach(weapon => {
                const stats = WEAPON_STATS[weapon.subType];
                if (stats) {
                    totalDPS += stats.dps + (weapon.level * stats.upgrade);
                }
            });
            return totalDPS * (1 + gameState.metaUpgrades.attack * 0.01);
        }

        function calculateHealRate() {
            const healItems = findItemsInInventory('heal');
            let healRate = 0;
            healItems.forEach(item => {
                healRate += 0.4 + (item.level * 0.2);
            });
            return healRate;
        }

        function calculateMaxShield() {
            const helmets = findItemsInInventory('armor', 'helmet');
            const vests = findItemsInInventory('armor', 'vest');
            let totalShield = 0;
            
            helmets.forEach(helmet => {
                totalShield += 25 + (helmet.level * 10); 
            });
            
            vests.forEach(vest => {
                totalShield += 50 + (vest.level * 20); 
            });
            
            return totalShield * (1 + gameState.metaUpgrades.defense * 0.01);
        }

        function calculateShieldGain() {
            return calculateMaxShield();
        }

        function updateStats() {
            document.getElementById('hp-value').textContent =
                `${Math.round(gameState.playerHp)}/${gameState.playerMaxHp}`;

        }

        function updateUI() {
            if (gameState.gamePhase === 'SHOP') {
                document.getElementById('resource-display').textContent = `Gold: ${gameState.gold}`;
            } else if (gameState.gamePhase === 'LOBBY') {
                document.getElementById('resource-display').textContent = `Gem: ${gameState.gems}`;
            } else if (gameState.gamePhase === 'COMBAT') {
                document.getElementById('resource-display').textContent = `DAY ${gameState.day}`;
            }

            if (gameState.gamePhase === 'COMBAT') {
                document.getElementById('hp-display').classList.remove('hidden');
                document.getElementById('hp-display').textContent = `HP: ${Math.round(gameState.playerHp)}`;
            } else {
                document.getElementById('hp-display').classList.add('hidden');
            }

            document.getElementById('day-number').textContent = gameState.day;

            const rerollBtn = document.getElementById('reroll-btn');
            if (rerollBtn) {
                rerollBtn.disabled = gameState.gold < 5;
            }

            const hpBtn = document.getElementById('hp-upgrade');
            if (hpBtn) {
                if (gameState.gamePhase === 'LOBBY') {
                    hpBtn.classList.remove('hidden');
                } else {
                    hpBtn.classList.add('hidden');
                }
                hpBtn.disabled = gameState.gems < 10 || gameState.metaUpgrades.hp >= 10;
            }
        }

        function showScreen(screenName) {
            const screens = ['lobby-screen', 'shop-screen', 'combat-screen'];
            screens.forEach(screen => {
                document.getElementById(screen).classList.add('hidden');
            });
            document.getElementById(screenName).classList.remove('hidden');
        }

        function startCombatLoop() {
            const weapons = findItemsInInventory('weapon');
            
            Object.values(gameState.weaponIntervals).forEach(interval => {
                clearInterval(interval);
            });
            gameState.weaponIntervals = {};

            weapons.forEach(weapon => {
                fireWeapon(weapon);
                
                const stats = WEAPON_STATS[weapon.subType];
                gameState.weaponIntervals[weapon.id] = setInterval(() => {
                    fireWeapon(weapon);
                }, stats.interval * 1000);
            });
            gameState.combatInterval = setInterval(() => {
                combatTick();
            }, 100);
        }

        function fireWeapon(weapon) {
            if (gameState.weaponCooldowns[weapon.id]) {
                return;
            }

            const stats = WEAPON_STATS[weapon.subType];
            const damage = stats.dps + (weapon.level * stats.upgrade);
            const actualDamage = damage * (1 + gameState.metaUpgrades.attack * 0.01);

            gameState.enemyHp = Math.max(0, gameState.enemyHp - actualDamage);
            
            showAttackEffects(weapon, actualDamage);
            
            const cooldownDuration = stats.interval * 1000;
            gameState.weaponCooldowns[weapon.id] = {
                startTime: Date.now(),
                duration: cooldownDuration,
                endTime: Date.now() + cooldownDuration
            };
            
            updateCombatUI();
        }

        function showAttackEffects(weapon, damage) {
            const characterImg = document.querySelector('.combat-character img');
            if (characterImg) {
                characterImg.classList.add('attack-flash');
                setTimeout(() => {
                    characterImg.classList.remove('attack-flash');
                }, 100);
            }

            createMuzzleFlash();

            setTimeout(() => {
                createImpactEffect();
                showEnemyHitEffect();
                showDamageNumber(damage, 'enemy');
            }, 100);
        }

        function createMuzzleFlash() {
            const muzzleFlash = document.createElement('div');
            muzzleFlash.className = 'muzzle-flash';
            muzzleFlash.style.left = '280px';
            muzzleFlash.style.bottom = '180px';
            
            const combatScreen = document.getElementById('combat-screen');
            combatScreen.appendChild(muzzleFlash);

            setTimeout(() => {
                if (muzzleFlash.parentNode) {
                    muzzleFlash.parentNode.removeChild(muzzleFlash);
                }
            }, 100);
        }

        function createImpactEffect() {
            const impactEffect = document.createElement('div');
            impactEffect.className = 'impact-effect';
            impactEffect.style.left = '55%';
            impactEffect.style.top = '60%';
            impactEffect.style.transform = 'translate(-50%, -50%)';
            
            const combatScreen = document.getElementById('combat-screen');
            combatScreen.appendChild(impactEffect);

            setTimeout(() => {
                if (impactEffect.parentNode) {
                    impactEffect.parentNode.removeChild(impactEffect);
                }
            }, 200);
        }

        function showEnemyHitEffect() {
            const enemyImg = document.querySelector('.combat-enemy img');
            if (enemyImg) {
                enemyImg.classList.add('hit-flash');
                setTimeout(() => {
                    enemyImg.classList.remove('hit-flash');
                }, 150);
            }
        }

        function showPlayerHitEffect(damage, isShieldDamage = false) {
            const gameContainer = document.querySelector('.game-container');
            gameContainer.classList.add('screen-shake');
            setTimeout(() => {
                gameContainer.classList.remove('screen-shake');
            }, 300);

            const combatScreen = document.getElementById('combat-screen');
            combatScreen.classList.add('damage-flash');
            setTimeout(() => {
                combatScreen.classList.remove('damage-flash');
            }, 200);

            const characterImg = document.querySelector('.combat-character img');
            if (characterImg) {
                characterImg.classList.add('hit-flash');
                setTimeout(() => {
                    characterImg.classList.remove('hit-flash');
                }, 150);
            }

            showDamageNumber(damage, isShieldDamage ? 'shield' : 'player');
        }

        function showDamageNumber(damage, type) {
            const damageNumber = document.createElement('div');
            damageNumber.className = `damage-number ${type}-damage`;
            damageNumber.textContent = Math.round(damage);

            let positionX, positionY;
            if (type === 'enemy') {
                positionX = '60%';
                positionY = '50%';
            } else {
                positionX = '20%';
                positionY = '70%';
            }

            damageNumber.style.left = positionX;
            damageNumber.style.top = positionY;
            damageNumber.style.transform = 'translate(-50%, -50%)';

            const combatScreen = document.getElementById('combat-screen');
            combatScreen.appendChild(damageNumber);

            setTimeout(() => {
                if (damageNumber.parentNode) {
                    damageNumber.parentNode.removeChild(damageNumber);
                }
            }, 1000);
        }

        function showShieldBreakEffect() {
            const shieldBreakFlash = document.createElement('div');
            shieldBreakFlash.style.position = 'absolute';
            shieldBreakFlash.style.left = '0';
            shieldBreakFlash.style.top = '0';
            shieldBreakFlash.style.width = '100%';
            shieldBreakFlash.style.height = '100%';
            shieldBreakFlash.style.background = 'rgba(170, 68, 255, 0.4)';
            shieldBreakFlash.style.zIndex = '90';
            shieldBreakFlash.style.opacity = '0';
            shieldBreakFlash.style.animation = 'shieldBreakFlash 0.3s ease-out';

            const combatScreen = document.getElementById('combat-screen');
            combatScreen.appendChild(shieldBreakFlash);

            if (!document.querySelector('#shield-break-keyframes')) {
                const style = document.createElement('style');
                style.id = 'shield-break-keyframes';
                style.textContent = `
                    @keyframes shieldBreakFlash {
                        0% { opacity: 0; }
                        50% { opacity: 0.6; }
                        100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            setTimeout(() => {
                if (shieldBreakFlash.parentNode) {
                    shieldBreakFlash.parentNode.removeChild(shieldBreakFlash);
                }
            }, 300);
        }

        function combatTick() {
            const currentTime = Date.now();
            
            Object.keys(gameState.weaponCooldowns).forEach(weaponId => {
                const cooldown = gameState.weaponCooldowns[weaponId];
                if (currentTime >= cooldown.endTime) {
                    delete gameState.weaponCooldowns[weaponId];
                }
            });

            const healRate = calculateHealRate();
            if (healRate > 0) {
                const maxHp = gameState.playerMaxHp + gameState.metaUpgrades.hp * 10;
                gameState.playerHp = Math.min(maxHp, gameState.playerHp + healRate * 0.1);
            }

            if (Date.now() % 2000 < 100) {
                const maxShield = calculateMaxShield();
                if (maxShield > 0) {
                    gameState.shieldHp = Math.min(maxShield, gameState.shieldHp + maxShield * 0.1);
                }
            }

            if (Date.now() % 1500 < 100) {
                const enemyDamage = 10 + (gameState.day - 1) * 2;
                const actualDamage = enemyDamage * (1 - gameState.metaUpgrades.defense * 0.01);
                
                if (gameState.shieldHp > 0) {
                    const shieldDamageTaken = Math.min(gameState.shieldHp, actualDamage);
                    gameState.shieldHp = Math.max(0, gameState.shieldHp - actualDamage);
                    
                    showPlayerHitEffect(shieldDamageTaken, true);
                    
                    if (gameState.shieldHp <= 0) {
                        setTimeout(() => {
                            showShieldBreakEffect();
                        }, 100);
                    }
                } else {
                    gameState.playerHp = Math.max(0, gameState.playerHp - actualDamage);
                    showPlayerHitEffect(actualDamage, false);
                }
            }

            if (gameState.playerHp <= 0) {
                const convertedGems = Math.floor(gameState.gold * GOLD_TO_GEM_RATE);
                gameState.gems += convertedGems;
                gameState.gold = 0;

                endCombat();
                alert('You are dead.');
                resetGame(); 
                return;
            }

            if (gameState.enemyHp <= 0) {
                endCombat();
                gameState.gamePhase = 'SHOP';
                gameState.gold += 10;
                gameState.gems += 1; 
                gameState.day += 1;
                generateShopItems();
                showScreen('shop-screen');
                updateUI();
            }
            checkCutsceneTrigger();
            updateCombatUI();
        }

        function endCombat() {
            if (gameState.combatInterval) {
                clearInterval(gameState.combatInterval);
                gameState.combatInterval = null;
            }

            Object.values(gameState.weaponIntervals).forEach(interval => {
                clearInterval(interval);
            });
            gameState.weaponIntervals = {};

            gameState.weaponCooldowns = {};
            gameState.shieldHp = 0;
            
            renderInventory();
        }

        function updateCombatUI() {
            const enemyHealthPercent = (gameState.enemyHp / gameState.enemyMaxHp) * 100;
            const enemyHealthFill = document.getElementById('enemy-health-fill');
            if (enemyHealthFill) {
                enemyHealthFill.style.width = `${enemyHealthPercent}%`;
            }
            
            const enemyHpText = document.getElementById('enemy-hp-text');
            const enemyMaxHpText = document.getElementById('enemy-max-hp-text');
            if (enemyHpText) enemyHpText.textContent = Math.round(gameState.enemyHp);
            if (enemyMaxHpText) enemyMaxHpText.textContent = gameState.enemyMaxHp;
    
            const shieldBar = document.getElementById('player-shield-bar');
            const shieldText = document.getElementById('player-shield-text');
            const shieldFill = document.getElementById('player-shield-fill');
            
            if (gameState.shieldHp > 0) {
                if (shieldBar) shieldBar.classList.remove('hidden');
                if (shieldText) {
                    shieldText.classList.remove('hidden');
                    shieldText.textContent = `Shield: ${Math.round(gameState.shieldHp)}`;
                }
                
                if (shieldFill) {
                    const maxShield = calculateMaxShield();
                    const shieldPercent = maxShield > 0 ? (gameState.shieldHp / maxShield) * 100 : 0;
                    shieldFill.style.width = `${Math.min(100, shieldPercent)}%`;
                }
            } else {
                if (shieldBar) shieldBar.classList.add('hidden');
                if (shieldText) shieldText.classList.add('hidden');
            }

            updateStats();
        }
        function showCutscene(imageSrc) {
            const overlay = document.getElementById('cutscene-overlay');
            const img = document.getElementById('cutscene-image');
            if (!overlay || !img) return;

            img.src = imageSrc;
            img.classList.remove('hidden'); 
            overlay.style.background = "rgba(0,0,0,0.8)";
            overlay.classList.remove('hidden');

            setTimeout(() => {
                overlay.classList.add('hidden');
                img.classList.add('hidden');
                img.src = '';              
                overlay.style.background = "none";
            }, 2000);
        }

        function resetGame() {
            endCombat();

            const preservedGems = gameState.gems;

            gameState = {
                playerHp: 100,
                playerMaxHp: 100,
                shieldHp: 0,
                maxShield: 0,
                gold: 200,         
                gems: preservedGems,  
                day: 1,
                gamePhase: 'LOBBY',
                inventory: Array(8).fill(null).map(() => Array(6).fill(null)),
                enemyHp: 100,
                enemyMaxHp: 100,
                metaUpgrades: { attack: 0, defense: 0, hp: 0 }, 
                weaponCooldowns: {},
                combatInterval: null,
                weaponIntervals: {},
                cutsceneShown: { "90": false, "70": false, "50": false, "30": false, "10": false } 
            };

            showScreen('lobby-screen');
            renderInventory();
            updateUI();
            generateShopItems();
        }
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' && e.ctrlKey) {
                e.preventDefault();
                resetGame();
            }
        });

        initGame();
    </script>
</body>
</html>